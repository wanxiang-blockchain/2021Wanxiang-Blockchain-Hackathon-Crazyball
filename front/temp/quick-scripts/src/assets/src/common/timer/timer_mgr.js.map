{"version":3,"sources":["assets/src/common/timer/timer_mgr.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import { handler, gen_handler } from \"../util\"\nimport { LinkList, LinkListNode } from \"../linklist\"\n\nexport class TimerMgr {\n    private static inst: TimerMgr;\n    private iterList: LinkList<TimerHandler>;\n    private pendingList: LinkList<TimerHandler>;\n    private pool: TimerHandler[];\n    private key: number;\n\n    private constructor() {\n        this.key = 0;\n        this.pool = [];\n        this.iterList = new LinkList<TimerHandler>();\n        this.pendingList = new LinkList<TimerHandler>();\n    }\n\n    static getInst(): TimerMgr {\n        if (!this.inst) {\n            this.inst = new TimerMgr();\n        }\n        return this.inst;\n    }\n\n    add(interval: number, delay: number, repeat: number, cb: handler, is_updater: boolean = false): number {\n        let th = this.pool.pop();\n        if (th) {\n            th.interval = interval;\n            th.delay = delay;\n            th.repeat = repeat;\n            th.elapsed = 0;\n            th.times = 0;\n            th.is_updater = is_updater;\n            th.cb = cb;\n        }\n        else {\n            th = { interval, delay, repeat, elapsed: 0, times: 0, is_updater, cb };\n        }\n        const key = this.pendingList.append(++this.key, th);\n        // cc.info(`[TimerMgr]addPending, key=${key}`);\n        return key;\n    }\n\n    remove(key: number) {\n        if (!this.removeIter(key)) {\n            this.removePending(key);\n        }\n    }\n\n    private removeIter(key: number) {\n        const node = this.iterList.remove(key);\n        if (node) {\n            this.pool.push(node.data);\n            // cc.info(`[TimerMgr]removeIter, key=${key}`);\n            return true;\n        }\n        return false;\n    }\n\n    private removePending(key: number) {\n        const node = this.pendingList.remove(key);\n        if (node) {\n            this.pool.push(node.data);\n            // cc.info(`[TimerMgr]removePending, key=${key}`);\n            return true;\n        }\n        return false;\n    }\n\n    loop(interval: number, cb: handler): number {\n        return this.add(interval, 0, 0, cb);\n    }\n\n    loopTimes(interval: number, repeat: number, cb: handler): number {\n        return this.add(interval, 0, repeat, cb);\n    }\n\n    frameLoop(cb: handler): number {\n        return this.add(1 / 24, 0, 0, cb);\n    }\n\n    delayLoop(interval: number, delay: number, cb: handler): number {\n        return this.add(interval, delay, 0, cb);\n    }\n\n    once(delay: number, cb: handler): number {\n        return this.add(0, delay, 1, cb);\n    }\n\n    add_updater(cb: handler): number {\n        return this.add(0, 0, 0, cb, true);\n    }\n\n    update(dt: number) {\n        let node = this.iterList.head;\n\n        //执行当前帧的定时器\n        while (node) {\n            if (node.data.is_updater) {\n                //先保存next引用，防止回调函数里回收node导致next被修改\n                const next = node.next;\n                node.data.cb.exec(dt);\n                node = next;\n                continue;\n            }\n\n            if (node.data.repeat != 0 && node.data.times >= node.data.repeat) {\n                const next = node.next;\n                this.removeIter(node.key);\n                node = next;\n                continue;\n            }\n\n            if (node.data.elapsed >= node.data.delay + node.data.interval) {\n                //exec回调可能会调用remove函数回收timerHandler.避免操作已回收的对象。\n                // cc.info(`[TimerMgr]execHandler, key=${node.key}`);\n                const next = node.next;\n                node.data.times++;\n                node.data.elapsed = node.data.delay;\n                node.data.cb.exec();\n                node = next;\n            }\n            else {\n                node.data.elapsed += dt;\n                node = node.next;\n            }\n        }\n\n        //添加下一帧的定时器\n        node = this.pendingList.head;\n        while (node) {\n            const key = node.key;\n            const th = node.data;\n            node = node.next;\n            this.pendingList.remove(key);\n            this.iterList.append(key, th);\n        }\n    }\n}\n\ntype TimerHandler = {\n    interval: number;    //执行间隔, 只执行一次的定时器值为0，单位秒\n    delay: number;       //延时多久执行，单位秒\n    repeat: number;      //要执行多少次，0表示无限次\n    elapsed: number;     //已过去的时间\n    times: number;       //已执行次数\n    is_updater: boolean; //是否每帧调用\n    cb: handler;         //回调函数\n}"]}